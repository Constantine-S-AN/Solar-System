<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar System Explorer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.9);
            z-index: 10;
        }
        h1 {
            font-weight: 200;
            letter-spacing: 8px;
            font-size: 1.5rem;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 100, 50, 0.8);
            margin: 0 0 5px 0;
        }
        p {
            font-size: 0.8rem;
            letter-spacing: 2px;
            opacity: 0.7;
            margin: 0;
            color: #ffccaa;
        }
        .instruction {
            margin-top: 10px;
            font-size: 0.7rem;
            color: #aaa;
            animation: pulse 2s infinite;
        }
        
        /* 语言切换按钮 */
        #lang-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            z-index: 20;
            font-size: 0.8rem;
            letter-spacing: 1px;
            transition: background 0.3s;
            backdrop-filter: blur(4px);
            border-radius: 4px;
        }
        #lang-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            color: #fff;
        }

        /* 行星标签样式 */
        .planet-label {
            position: absolute;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 400;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            pointer-events: auto; /* 允许点击 */
            cursor: pointer;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s, background 0.3s;
            white-space: nowrap;
            z-index: 5;
        }
        .planet-label:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.8);
            z-index: 6;
        }
        /* 聚焦状态下的返回按钮 */
        #reset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(20, 100, 200, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.5);
            color: #fff;
            cursor: pointer;
            display: none;
            z-index: 20;
            font-size: 0.9rem;
            letter-spacing: 1px;
            backdrop-filter: blur(4px);
        }
        #reset-btn:hover {
            background: rgba(20, 100, 200, 0.6);
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 语言切换 -->
    <button id="lang-btn">EN / 中</button>

    <div id="ui-container">
        <h1 id="ui-title">SOLAR SYSTEM</h1>
        <p id="ui-subtitle">SOLAR SYSTEM EXPLORER</p>
        <div id="ui-instruction" class="instruction">
            Click label to focus | Click empty space to reset<br>
            W/S: Zoom | A/D: Rotate
        </div>
    </div>

    <button id="reset-btn">Return to Panorama (ESC)</button>
    
    <!-- 标签容器 -->
    <div id="labels-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 配置 ---
        const CONFIG = {
            sunSize: 6,
            starCount: 5000,
            asteroidCount: 2500,
            bloomStrength: 1.5,
            bloomRadius: 0.5,
            bloomThreshold: 0.2
        };

        // --- 语言资源 ---
        const TEXTS = {
            en: {
                title: "SOLAR SYSTEM",
                subtitle: "SOLAR SYSTEM EXPLORER",
                instruction: "Click label to focus | Click empty space to reset<br>Hold Click to Accelerate<br>W/S: Zoom | A/D: Rotate",
                reset: "Return to Panorama (ESC)"
            },
            zh: {
                title: "太阳系",
                subtitle: "星 际 · 探 索",
                instruction: "点击标签聚焦星球 | 点击空白返回<br>长按鼠标加速时间<br>W/S: 缩放 | A/D: 旋转",
                reset: "返回全景 (ESC)"
            }
        };

        // --- 全局变量 ---
        let scene, camera, renderer, composer;
        let sunMesh, planets = [], orbitLines = [];
        let asteroidBelt, starSystem, cometSystem;
        let clock = new THREE.Clock();
        let currentLang = 'en'; // 默认英语
        
        // 交互与摄像机
        const mouse = new THREE.Vector2(0, 0);
        const targetMouse = new THREE.Vector2(0, 0);
        let isPressed = false;
        let timeScale = 1.0; 
        
        // 摄像机控制
        let cameraRadius = 80;
        let cameraRotationOffset = 0;
        const minRadius = 20;
        const maxRadius = 200;
        
        // 聚焦系统
        let focusTarget = null; // 当前聚焦的行星对象
        let cameraLookAt = new THREE.Vector3(0, 0, 0); // 摄像机观察点
        
        // 辅助变量 (放在这里避免ReferenceError)
        const tempV = new THREE.Vector3();

        // 行星数据 (增加 nameZh)
        const PLANET_DATA = [
            { name: 'Mercury', nameZh: '水星', type: 'rocky', color: '#aaaaaa', dist: 10, size: 0.4, speed: 4.0 },
            { name: 'Venus', nameZh: '金星', type: 'atmosphere', color: '#eecb8b', dist: 14, size: 0.8, speed: 3.0 },
            { 
                name: 'Earth', nameZh: '地球', type: 'earth', color: '#2233ff', dist: 19, size: 0.9, speed: 2.5,
                moons: [{ name: 'Moon', nameZh: '月球', size: 0.25, dist: 2.0, speed: 3.0, color: '#dddddd', type: 'rocky' }] 
            },
            { name: 'Mars', nameZh: '火星', type: 'rocky', color: '#c1440e', dist: 24, size: 0.6, speed: 2.0 },
            { 
                name: 'Jupiter', nameZh: '木星', type: 'gas', color: '#c99039', dist: 32, size: 2.2, speed: 1.0,
                moons: [
                    { size: 0.2, dist: 3.2, speed: 2.5, color: '#aaaaaa' }, 
                    { size: 0.15, dist: 4.0, speed: 2.0, color: '#ccbbaa' }
                ]
            },
            { name: 'Saturn', nameZh: '土星', type: 'gas', color: '#e4d5b6', dist: 42, size: 1.8, speed: 0.8, ring: true },
            { name: 'Uranus', nameZh: '天王星', type: 'gas', color: '#7de3f4', dist: 52, size: 1.2, speed: 0.5 },
            { name: 'Neptune', nameZh: '海王星', type: 'gas', color: '#3e54e8', dist: 60, size: 1.1, speed: 0.4 }
        ];

        init();
        animate();

        function init() {
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            // 摄像机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 80);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 后期处理
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                CONFIG.bloomStrength,
                CONFIG.bloomRadius,
                CONFIG.bloomThreshold
            );
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            // 光照
            const ambientLight = new THREE.AmbientLight(0x999999);
            scene.add(ambientLight);

            const sunLight = new THREE.PointLight(0xffffff, 5.0, 300);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // 创建物体
            createSun();
            createPlanets();
            createAsteroidBelt();
            createStars();
            createComet(); 

            // 事件监听
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown); 
            window.addEventListener('mouseup', () => isPressed = false);
            window.addEventListener('touchstart', (e) => { isPressed = true; onTouchMove(e); }, {passive: false});
            window.addEventListener('touchend', () => isPressed = false);
            window.addEventListener('touchmove', onTouchMove, {passive: false});
            window.addEventListener('keydown', onKeyDown);
            
            document.getElementById('reset-btn').addEventListener('click', resetCamera);
            document.getElementById('lang-btn').addEventListener('click', toggleLanguage);

            // 初始化文本
            updateTexts();
        }

        // --- 语言切换逻辑 ---
        function toggleLanguage() {
            currentLang = currentLang === 'en' ? 'zh' : 'en';
            updateTexts();
        }

        function updateTexts() {
            const t = TEXTS[currentLang];
            document.getElementById('ui-title').textContent = t.title;
            document.getElementById('ui-subtitle').textContent = t.subtitle;
            document.getElementById('ui-instruction').innerHTML = t.instruction;
            document.getElementById('reset-btn').textContent = t.reset;

            // 更新所有行星标签
            planets.forEach(p => {
                if(p.label && p.data) {
                    p.label.textContent = currentLang === 'en' ? p.data.name : p.data.nameZh;
                }
            });
        }

        // --- 交互逻辑 ---

        function onMouseDown(event) {
            isPressed = true;
        }
        
        function focusOnPlanet(planetObj) {
            focusTarget = planetObj;
            document.getElementById('reset-btn').style.display = 'block';
            
            // 聚焦时稍微减慢时间，方便观察
            timeScale = 0.2; 
        }

        function resetCamera() {
            focusTarget = null;
            document.getElementById('reset-btn').style.display = 'none';
            timeScale = 1.0; // 恢复速度
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            const step = 5;
            const rotateStep = 0.1;

            if (key === 'escape') resetCamera();

            if (!focusTarget) { 
                if (key === 'w' || key === 'arrowup') cameraRadius = Math.max(minRadius, cameraRadius - step);
                if (key === 's' || key === 'arrowdown') cameraRadius = Math.min(maxRadius, cameraRadius + step);
            } else {
                if (key === 'w') cameraRadius = Math.max(5, cameraRadius - 1);
                if (key === 's') cameraRadius = Math.min(20, cameraRadius + 1);
            }

            if (key === 'a' || key === 'arrowleft') cameraRotationOffset -= rotateStep;
            if (key === 'd' || key === 'arrowright') cameraRotationOffset += rotateStep;
        }

        // --- 程序化纹理 ---
        function generatePlanetTexture(type, baseColorStr) {
            const canvas = document.createElement('canvas');
            const size = 512;
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const baseColor = new THREE.Color(baseColorStr);

            ctx.fillStyle = baseColorStr;
            ctx.fillRect(0, 0, size, size);

            function noise(amount, scale, colorObj) {
                for (let i = 0; i < amount; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const r = Math.random() * scale;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${colorObj.r*255}, ${colorObj.g*255}, ${colorObj.b*255}, 0.1)`;
                    ctx.fill();
                }
            }
            function bands(count, colorObj) {
                for(let i=0; i<count; i++) {
                    const y = Math.random() * size;
                    const h = Math.random() * (size / 5);
                    ctx.fillStyle = `rgba(${colorObj.r*255}, ${colorObj.g*255}, ${colorObj.b*255}, 0.1)`;
                    ctx.fillRect(0, y, size, h);
                }
            }

            if (type === 'rocky') {
                noise(400, 10, new THREE.Color('#000000'));
                noise(200, 20, new THREE.Color('#444444'));
            } else if (type === 'gas') {
                const dark = baseColor.clone().multiplyScalar(0.8);
                const light = baseColor.clone().offsetHSL(0, 0, 0.2);
                bands(20, dark); bands(20, light); noise(200, 30, dark);
            } else if (type === 'atmosphere') {
                noise(1000, 40, new THREE.Color('#ffffff'));
                noise(500, 20, baseColor.clone().offsetHSL(0.05, 0, 0));
            } else if (type === 'earth') {
                ctx.fillStyle = '#1144aa'; ctx.fillRect(0, 0, size, size);
                for(let i=0; i<15; i++) {
                    ctx.beginPath();
                    let x = Math.random() * size; let y = Math.random() * size;
                    ctx.moveTo(x, y);
                    for(let j=0; j<8; j++) {
                        x += (Math.random() - 0.5) * 150; y += (Math.random() - 0.5) * 150;
                        ctx.lineTo(x, y);
                    }
                    ctx.fillStyle = '#228822'; ctx.fill();
                }
                ctx.globalAlpha = 0.4;
                for(let i=0; i<300; i++) {
                    const x = Math.random() * size; const y = Math.random() * size;
                    const w = Math.random() * 80;
                    ctx.fillStyle = '#ffffff'; ctx.fillRect(x, y, w, 10);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- 创建太阳 ---
        function createSun() {
            const geometry = new THREE.SphereGeometry(CONFIG.sunSize, 64, 64);
            // 使用 Shader 模拟动态表面
            const vertexShader = `
                varying vec2 vUv; varying vec3 vPosition; uniform float uTime;
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 = v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute( permute( permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857;
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                }
                void main() {
                    vUv = uv; vPosition = position;
                    float noise = snoise(position * 0.4 + vec3(uTime * 0.4));
                    vec3 newPos = position + normal * noise * 0.3;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
                }
            `;
            const fragmentShader = `
                varying vec3 vPosition; uniform float uTime;
                void main() {
                    float intensity = 1.0 - length(vPosition) / 10.0; 
                    vec3 color1 = vec3(1.2, 0.4, 0.1); vec3 color2 = vec3(1.1, 0.9, 0.2);
                    float pulse = sin(uTime * 1.5 + vPosition.y * 0.5) * 0.15;
                    vec3 finalColor = mix(color1, color2, 0.6 + pulse);
                    gl_FragColor = vec4(finalColor * 2.0, 1.0);
                }
            `;
            const shaderMat = new THREE.ShaderMaterial({
                vertexShader, fragmentShader, uniforms: { uTime: { value: 0 } }
            });

            sunMesh = new THREE.Mesh(geometry, shaderMat);
            scene.add(sunMesh);

            const spriteMat = new THREE.SpriteMaterial({
                map: createGlowTexture(), color: 0xffaa00, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(35, 35, 1);
            scene.add(sprite);
        }

        // --- 创建彗星 ---
        function createComet() {
            const headGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const headMat = new THREE.MeshBasicMaterial({ color: 0xaaddff });
            const cometMesh = new THREE.Mesh(headGeo, headMat);
            
            const particleCount = 200;
            const trailGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const opacities = new Float32Array(particleCount);
            
            for(let i=0; i<particleCount; i++) {
                positions[i*3] = 0; positions[i*3+1] = 0; positions[i*3+2] = 0;
                opacities[i] = i / particleCount; 
            }
            
            trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            trailGeo.setAttribute('alpha', new THREE.BufferAttribute(opacities, 1));

            const trailMat = new THREE.ShaderMaterial({
                vertexShader: `
                    attribute float alpha;
                    varying float vAlpha;
                    void main() {
                        vAlpha = alpha;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 - alpha) * 8.0;
                    }
                `,
                fragmentShader: `
                    varying float vAlpha;
                    void main() {
                        gl_FragColor = vec4(0.5, 0.8, 1.0, vAlpha * 0.5);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const trail = new THREE.Points(trailGeo, trailMat);
            scene.add(trail);
            scene.add(cometMesh);

            cometSystem = {
                mesh: cometMesh,
                trail: trail,
                trailPositions: [], // 历史位置
                angle: 0,
                speed: 1.5,
                dist: 90 
            };
        }

        // --- 创建行星与标签 ---
        function createPlanets() {
            const labelsContainer = document.getElementById('labels-container');

            PLANET_DATA.forEach(data => {
                const texture = generatePlanetTexture(data.type, data.color);
                const geo = new THREE.SphereGeometry(data.size, 64, 64);
                const mat = new THREE.MeshStandardMaterial({
                    map: texture, roughness: 0.8, metalness: 0.1,
                    emissive: new THREE.Color(data.color), emissiveIntensity: 0.15
                });
                
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true; mesh.receiveShadow = true;

                // 地球大气层
                if(data.type === 'earth') {
                    const atmoGeo = new THREE.SphereGeometry(data.size * 1.2, 32, 32);
                    const atmoMat = new THREE.ShaderMaterial({
                        vertexShader: `
                            varying vec3 vNormal;
                            void main() {
                                vNormal = normalize(normalMatrix * normal);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            varying vec3 vNormal;
                            void main() {
                                float intensity = pow(0.7 - dot(vNormal, vec3(0, 0, 1.0)), 2.0);
                                gl_FragColor = vec4(0.2, 0.6, 1.0, 1.0) * intensity * 0.8;
                            }
                        `,
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide,
                        transparent: true
                    });
                    const atmo = new THREE.Mesh(atmoGeo, atmoMat);
                    mesh.add(atmo);
                }

                const orbitGeo = new THREE.RingGeometry(data.dist - 0.05, data.dist + 0.05, 128);
                const orbitMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.08, blending: THREE.AdditiveBlending
                });
                const orbit = new THREE.Mesh(orbitGeo, orbitMat);
                orbit.rotation.x = Math.PI / 2;
                scene.add(orbit);

                if (data.ring) {
                    const ringGeo = new THREE.RingGeometry(data.size * 1.4, data.size * 2.5, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0xccaacc, side: THREE.DoubleSide, transparent: true, opacity: 0.6
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2;
                    mesh.add(ring);
                }

                scene.add(mesh);

                // 卫星
                let moons = [];
                if (data.moons) {
                    data.moons.forEach(moonData => {
                        const mTexture = generatePlanetTexture(moonData.type || 'rocky', moonData.color);
                        const mGeo = new THREE.SphereGeometry(moonData.size, 32, 32);
                        const mMat = new THREE.MeshStandardMaterial({
                            map: mTexture, roughness: 0.9,
                            emissive: new THREE.Color(moonData.color), emissiveIntensity: 0.1
                        });
                        const mMesh = new THREE.Mesh(mGeo, mMat);
                        mMesh.castShadow = true; mMesh.receiveShadow = true;
                        scene.add(mMesh);
                        moons.push({ mesh: mMesh, dist: moonData.dist, speed: moonData.speed, angle: Math.random() * Math.PI * 2 });
                    });
                }

                // 创建 DOM 标签 (初始显示 name)
                const labelDiv = document.createElement('div');
                labelDiv.className = 'planet-label';
                labelDiv.textContent = data.name;
                labelsContainer.appendChild(labelDiv);
                
                // 点击标签聚焦
                labelDiv.addEventListener('click', (e) => {
                    e.stopPropagation(); // 防止触发全局点击
                    if (focusTarget !== mesh) {
                        cameraRadius = data.size * 5 + 5; // 默认聚焦距离
                    }
                    focusOnPlanet(mesh);
                });

                planets.push({ 
                    mesh: mesh, data: data, angle: Math.random() * Math.PI * 2, moons: moons,
                    label: labelDiv
                });
            });
        }

        function createAsteroidBelt() {
            const geometry = new THREE.DodecahedronGeometry(0.2, 0); 
            const material = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.2, flatShading: true });
            asteroidBelt = new THREE.InstancedMesh(geometry, material, CONFIG.asteroidCount);
            asteroidBelt.castShadow = true; asteroidBelt.receiveShadow = true;
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            const rockColors = [0x777777, 0x666666, 0x555555, 0x665544];

            for (let i = 0; i < CONFIG.asteroidCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 26 + Math.random() * 4;
                dummy.position.set(Math.cos(angle) * radius, (Math.random() - 0.5) * 1.5, Math.sin(angle) * radius);
                dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                const scale = 0.5 + Math.random() * 1.5;
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                asteroidBelt.setMatrixAt(i, dummy.matrix);
                color.setHex(rockColors[Math.floor(Math.random() * rockColors.length)]);
                asteroidBelt.setColorAt(i, color);
            }
            scene.add(asteroidBelt);
        }

        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = []; const colors = [];
            for(let i=0; i<CONFIG.starCount; i++) {
                positions.push((Math.random()-0.5)*800, (Math.random()-0.5)*800, (Math.random()-0.5)*800);
                const c = new THREE.Color();
                const r = Math.random();
                if(r > 0.9) c.setHex(0xaaaaff); else if(r > 0.7) c.setHex(0xffddaa); else c.setHex(0xffffff);
                colors.push(c.r, c.g, c.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ vertexColors: true, size: 1.2 });
            starSystem = new THREE.Points(geometry, material);
            scene.add(starSystem);
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64,64,0,64,64,64);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0,0,128,128);
            return new THREE.CanvasTexture(canvas);
        }

        // --- 辅助：标签更新 ---
        function updateLabels() {
            planets.forEach(p => {
                if (!p.label) return;

                p.mesh.updateWorldMatrix(true, false);
                p.mesh.getWorldPosition(tempV);
                
                tempV.project(camera);

                const isBehind = tempV.z > 1;
                
                if (isBehind) {
                    p.label.style.display = 'none';
                } else {
                    p.label.style.display = 'block';
                    const x = (tempV.x * .5 + .5) * window.innerWidth;
                    const y = (tempV.y * -.5 + .5) * window.innerHeight;
                    p.label.style.transform = `translate(-50%, -50%) translate(${x}px, ${y - 30}px)`;
                    
                    const dist = camera.position.distanceTo(p.mesh.position);
                    p.label.style.opacity = Math.max(0.3, 1.0 - dist / 200);
                }
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(e) {
            targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        }
        function onTouchMove(e) {
            if(e.touches.length > 0) {
                targetMouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                targetMouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            const baseTimeScale = focusTarget ? 0.2 : 1.0; 
            const accelTimeScale = isPressed ? 8.0 : baseTimeScale;
            timeScale += (accelTimeScale - timeScale) * 0.05;

            if(sunMesh) sunMesh.material.uniforms.uTime.value = elapsedTime;
            if(asteroidBelt) asteroidBelt.rotation.y += 0.015 * dt * timeScale;

            if(cometSystem) {
                cometSystem.angle += 0.3 * dt * timeScale;
                const a = 120; const b = 40;
                const cx = Math.cos(cometSystem.angle) * a;
                const cz = Math.sin(cometSystem.angle) * b;
                const cy = Math.sin(cometSystem.angle * 2) * 20;
                
                cometSystem.mesh.position.set(cx, cy, cz);
                
                cometSystem.mesh.lookAt(0,0,0); 
                
                cometSystem.trailPositions.unshift(cometSystem.mesh.position.clone());
                if(cometSystem.trailPositions.length > 200) cometSystem.trailPositions.pop();
                
                const posAttr = cometSystem.trail.geometry.attributes.position;
                for(let i=0; i<cometSystem.trailPositions.length; i++) {
                    posAttr.setXYZ(i, cometSystem.trailPositions[i].x, cometSystem.trailPositions[i].y, cometSystem.trailPositions[i].z);
                }
                posAttr.needsUpdate = true;
            }

            planets.forEach(p => {
                p.angle += p.data.speed * 0.05 * dt * timeScale;
                p.mesh.position.x = Math.cos(p.angle) * p.data.dist;
                p.mesh.position.z = Math.sin(p.angle) * p.data.dist;
                p.mesh.rotation.y += 0.5 * dt * timeScale;
                
                if(p.moons) {
                    p.moons.forEach(m => {
                        m.angle += m.speed * 0.5 * dt * timeScale;
                        m.mesh.position.x = p.mesh.position.x + Math.cos(m.angle) * m.dist;
                        m.mesh.position.z = p.mesh.position.z + Math.sin(m.angle) * m.dist;
                        m.mesh.position.y = Math.sin(m.angle * 1.5) * (m.dist * 0.2);
                        m.mesh.rotation.y += 1.0 * dt;
                    });
                }
            });

            let targetLookAt = new THREE.Vector3(0, 0, 0);
            let targetCamPos = new THREE.Vector3();

            if (focusTarget) {
                focusTarget.getWorldPosition(targetLookAt);
                
                const theta = cameraRotationOffset + Math.PI / 2; 
                const phi = Math.PI / 4; 
                
                const offsetX = cameraRadius * Math.sin(theta);
                const offsetZ = cameraRadius * Math.cos(theta);
                const offsetY = cameraRadius * 0.5;

                targetCamPos.set(
                    targetLookAt.x + offsetX,
                    targetLookAt.y + offsetY,
                    targetLookAt.z + offsetZ
                );
            } else {
                mouse.x += (targetMouse.x - mouse.x) * 0.05;
                mouse.y += (targetMouse.y - mouse.y) * 0.05;
                
                const theta = (mouse.x * Math.PI * 0.4) + cameraRotationOffset;
                const phi = THREE.MathUtils.clamp((1 - mouse.y) * Math.PI * 0.5, 0.1, Math.PI / 2 - 0.1);

                targetCamPos.x = cameraRadius * Math.sin(theta) * Math.cos(phi);
                targetCamPos.z = cameraRadius * Math.cos(theta) * Math.cos(phi);
                targetCamPos.y = cameraRadius * Math.sin(phi) * 0.8 + 10;
            }

            camera.position.lerp(targetCamPos, 0.05);
            cameraLookAt.lerp(targetLookAt, 0.05);
            camera.lookAt(cameraLookAt);

            updateLabels();

            composer.render();
        }
    </script>
</body>
</html>